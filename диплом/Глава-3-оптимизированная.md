2

<a name="_hlk156314416"></a><a name="_toc196130625"></a><a name="_toc196130511"></a><a name="x1c93478544777edb905d02e8cfbbf50022c41dc"></a>МИНОБРНАУКИ РОССИИ

Федеральное государственное бюджетное образовательное учреждение 

высшего образования

«ВЛАДИВОСТОКСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ»

(ФГБОУ ВО «ВВГУ»)

Институт информационных технологий и анализа данных

Кафедра информационных технологий и систем 



ОТЧЕТ ПО ПРОИЗВОДСТВЕННОЙ 

ПРЕДДИПЛОМНОЙ ПРАКТИКЕ





Студент 

гр. БПИ-21-МП1	       	      \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ И.И. Рязанов

Руководитель 

Доктор техн. наук, доцент   \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ В.М. Гриняк



Владивосток 2025
# <a name="_toc196130946"></a><a name="_toc196173515"></a>Содержание
[Содержание	2](#_toc196173515)

[1. Разработка интернет-витрины “Дому мебель”	4](#_toc196173516)

[1.1. Подход к разработке и организация процесса	4](#_toc196173517)

[1.2. Требования и пользовательские истории	5](#_toc196173518)

[1.3. Реализация серверной части	11](#_toc196173519)

`    `[1.3.1. Структура серверной части	11](#_toc196173520)

`    `[1.3.2. Реализация REST API	11](#_toc196173521)

`    `[1.3.3. Реализация бизнес-логики	12](#_toc196173522)

`    `[1.3.4. Взаимодействие с базой данных	14](#_toc196173523)

`    `[1.3.5. Обработка ошибок и логирование	15](#_toc196173524)

[1.4. Реализация клиентской части	17](#_toc196173525)

`    `[1.4.1. Структура клиентского приложения	17](#_toc196173526)

`    `[1.4.2. Реализация маршрутизации и навигации	18](#_toc196173527)

`    `[1.4.3. Разработка пользовательского интерфейса	19](#_toc196173528)

`    `[1.4.4. Реализация адаптивного дизайна	20](#_toc196173529)

[1.5. Тестирование системы	23](#_toc196173530)

[1.6. Развертывание и внедрение	25](#_toc196173531)

[1.7. Оценка результатов разработки	27](#_toc196173532)

[Список использованных источников	29](#_toc196173533)

[Приложение А. Листинги исходного кода	30](#_toc196173534)

[А.1. Примеры серверной части	30](#_toc196173535)

`    `[А.1.1. Доменная модель товара	30](#_toc196173536)

`    `[А.1.2. SQL запросы репозитория товаров	31](#_toc196173537)

`    `[А.1.3. Реализация паттерна Unit of Work	32](#_toc196173538)

`    `[А.1.4. SQL индексы для оптимизации производительности	33](#_toc196173539)

`    `[А.1.5. SQL материализованные представления	33](#_toc196173540)

[А.2. Примеры клиентской части	35](#_toc196173541)

`    `[А.2.1. Компонент маршрутизации приложения	35](#_toc196173542)

`    `[А.2.2. Компонент защищенного маршрута	35](#_toc196173543)

`    `[А.2.3. Компонент главного меню	36](#_toc196173544)

`    `[А.2.4. Компонент хлебных крошек	36](#_toc196173545)

`    `[А.2.5. Хук для работы с параметрами фильтрации	37](#_toc196173546)

`    `[А.2.6. Компонент страницы каталога	38](#_toc196173547)

`    `[А.2.7. Стили цветовой палитры приложения	39](#_toc196173548)

`    `[А.2.8. Стили типографики приложения	39](#_toc196173549)

`    `[А.2.9. Компонент кнопки	40](#_toc196173550)

`    `[А.2.10. Компонент карточки	41](#_toc196173551)

`    `[А.2.11. Стили сетки для адаптивной верстки	41](#_toc196173552)

`    `[А.2.12. Компонент адаптивного изображения	43](#_toc196173553)

`    `[А.2.13. Компонент виртуализированного списка товаров	43](#_toc196173554)




# <a name="_toc196130587"></a><a name="_toc196173516"></a>1. Разработка интернет-витрины “Дому мебель”
Эта глава посвящена практической реализации интернет-витрины "Дому мебель". В ней подробно рассматривается весь процесс разработки программного обеспечения от этапа планирования и организации до развертывания и оценки результатов.
## <a name="x3c01b0b1fc22de68913b240c10ad867dc8cb97f"></a><a name="_toc196130512"></a><a name="_toc196130588"></a><a name="_toc196173517"></a>1.1. Подход к разработке и организация процесса
<a name="описание-ролей-участников-проекта"></a>В данном разделе описывается организационная структура проекта. Отличительной особенностью разработки интернет-витрины “Дому мебель” является то, что проект выполнялся индивидуально одним разработчиком. При разработке автор самостоятельно выполнял все необходимые роли:

- Разработчик серверной части - работа с базой данных и создание API;
- Разработчик клиентской части - создание интерфейса пользователя с помощью React. Реализация компонентного подхода и адаптивного дизайна;
- Дизайнер интерфейса - разработка UI/UX решений, работа над эргономикой пользовательского интерфейса;
- Тестировщик - разработка и проведение тестов различного уровня, от модульных до интеграционных;

Такой подход, хотя и требует от разработчика универсальности и наличия широкого спектра компетенций, но при этом позволяет обеспечить целостность видения проекта и отсутствие коммуникационных барьеров между различными этапами разработки.

<a name="описание-методологии-разработки"></a><a name="описание-проектного-инструментария"></a><a name="работа-с-системой-контроля-версий"></a>Для контроля версий проекта была выбрана система Git, которая поддерживает ведение нескольких версий (веток) для разных целей:

- Ветка main для стабильных релизов;
- Ветка develop для текущей разработки;
- Тематические ветки feature/[название-функции] для отдельных функций;
- Ветки hotfix/[описание-проблемы] для срочных исправлений<a name="программное-обеспечение-проекта"></a>;


## <a name="_toc196130513"></a><a name="_toc196130589"></a><a name="_toc196173518"></a>1.2. Требования и пользовательские истории
<a name="основные-требования-системы"></a><a name="требования-и-пользовательские-истории"></a>Таблица 1 – Основные требования системы

|№ требования|Описание требования|Приоритет|
| - | - | - |
|REQ-001|Система должна обеспечивать просмотр каталога мебели с фильтрацией и сортировкой|Высокий|
|REQ-002|Система должна предоставлять детальную информацию о каждом товаре|Высокий|
|REQ-003|Система должна иметь административный интерфейс для управления товарами|Высокий|
|REQ-004|Система должна быть доступна и корректно работать на мобильных устройствах|Средний|
|REQ-005|Система должна обеспечивать безопасное хранение данных пользователей|Высокий|
|REQ-006|Система должна позволять пользователям добавлять товары в корзину и оформлять заказ|Высокий|
|REQ-007|Система должна предоставлять администраторам аналитические данные о продажах|Средний|
|REQ-008|Система должна обеспечивать высокую производительность при большом количестве товаров|Высокий|

<a name="пользовательские-истории"></a>Представленные требования (таблица 1) определяют ключевые характеристики системы, установлены с учетом приоритетов бизнеса, и служат ориентирами для оценки успешности проекта. Высокоприоритетные требования были реализованы в первую очередь, что позволило сосредоточиться на создании основной ценности для конечных пользователей.

Таблица 2 – Пользовательские истории

|№ истории|Формулировка истории|Стоимость (ч/ч)|Номер тестового сценария|
| :- | :- | :- | :- |
|US-001|КАК покупатель Я ХОЧУ просматривать каталог товаров по категориям ДЛЯ ТОГО ЧТОБЫ быстро находить нужную мебель|8|TS-001|
|US-002|КАК покупатель Я ХОЧУ видеть детальное описание товара с фотографиями ДЛЯ ТОГО ЧТОБЫ получить полное представление о мебели|12|TS-002|
|US-003|<p>КАК менеджер магазина Я ХОЧУ добавлять новые товары в каталог ДЛЯ ТОГО ЧТОБЫ </p><p>предоставлять актуальную информацию клиентам</p>|16|TS-003|
|US-004|КАК менеджер магазина Я ХОЧУ редактировать информацию о существующих товарах ДЛЯ ТОГО ЧТОБЫ поддерживать актуальность данных|10|TS-004|
|US-005|КАК покупатель Я ХОЧУ иметь возможность фильтровать товары по параметрам ДЛЯ ТОГО ЧТОБЫ быстро находить мебель по моим требованиям|14|TS-005|
|US-006|КАК покупатель Я ХОЧУ добавлять товары в корзину ДЛЯ ТОГО ЧТОБЫ сформировать заказ|18|TS-006|
|US-007|КАК покупатель Я ХОЧУ оформить заказ онлайн ДЛЯ ТОГО ЧТОБЫ сэкономить время|20|TS-007|
|US-008|КАК менеджер магазина Я ХОЧУ получать уведомления о новых заказах ДЛЯ ТОГО ЧТОБЫ оперативно их обрабатывать|12|TS-008|
|US-009|КАК менеджер магазина Я ХОЧУ видеть аналитическую информацию о продажах ДЛЯ ТОГО ЧТОБЫ анализировать эффективность работы|16|TS-009|
|US-010|КАК администратор Я ХОЧУ управлять правами доступа пользователей ДЛЯ ТОГО ЧТОБЫ обеспечить безопасность системы|14|TS-010|

<a name="тестовые-сценарии"></a>Пользовательские истории из таблицы 2 представляют собой детализацию требований с точки зрения конкретных пользователей системы. Используя формат "КАК [роль] Я ХОЧУ [действие] ДЛЯ ТОГО ЧТОБЫ [ценность]", истории концентрируются на потребностях пользователей и бизнес-ценности каждой функции. Оценка трудоемкости позволила эффективно планировать работу, а привязка к тестовым сценариям обеспечила проверку реализации каждой истории. 

Таблица 3 – Тестовые сценарии

|№ теста|Описание тестового сценария|Ожидаемый результат|Покрываемые требования|
| :- | :- | :- | :- |
|TS-001|Проверка навигации по категориям товаров|Корректное отображение товаров соответствующей категории/подкатегории|US-001, REQ-001|
|TS-002|Просмотр детальной информации о товаре|Отображение полной информации о товаре с изображениями|US-002, REQ-002|
|TS-003|Добавление новых товаров|Товар добавлен в каталог с корректными данными|US-003, REQ-003|
|TS-004|Редактирование существующих товаров|Обновленная информация отображается в каталоге|US-004, REQ-003|
|TS-005|Фильтрация и сортировка товаров|Товары отфильтрованы и отсортированы согласно заданным параметрам|US-005, REQ-001, REQ-008|
|TS-006|Добавление товаров в корзину|Товар с выбранными параметрами добавлен в корзину|US-006, REQ-006|
|TS-007|Оформление заказа|Заказ успешно создан, отправлено подтверждение|US-007, REQ-006|
|TS-008|Система уведомлений о заказах|Менеджер получает уведомление о новом заказе|US-008, REQ-003|
|TS-009|Аналитическая информация о продажах|Отображение актуальных данных в графиках и отчетах|US-009, REQ-007|
|TS-010|Управление правами доступа|Пользователь имеет доступ только к разрешенным функциям|US-010, REQ-005|
|TS-011|Адаптивность интерфейса|Корректное отображение и работа на мобильных устройствах|REQ-004|
|TS-012|Проверка производительности|Время отклика не превышает 500 миллисекунд при высокой нагрузке|REQ-008|

<a name="матрица-покрытия-требований-тестами"></a>Тестовые сценарии из таблицы 3 обеспечивают формализованный подход к проверке функциональности системы. Они определяют конкретные шаги и ожидаемые результаты для каждого тестируемого аспекта приложения, что позволяет систематически проверять соответствие реализации требованиям. Представленные сценарии охватывают все ключевые функции интернет-витрины и служат основой для разработки автоматизированных и ручных тестов. Явная связь с пользовательскими историями и требованиями позволяет отслеживать полноту тестирования системы.

Таблица 4 – Матрица покрытия требований тестами

|Требования/Тесты|TS-001|TS-002|TS-003|TS-004|TS-005|TS-006|TS-007|TS-008|TS-009|TS-010|TS-011|TS-012|
| :- | :- | :- | :- | :- | :- | :- | :- | :- | :- | :- | :- | :- |
|REQ-001|X||||X||||||||
|REQ-002||X|||||||||||
|REQ-003|||X|X||||X|||||
|REQ-004|||||||||||X||
|REQ-005||||||||||X|||
|REQ-006||||||X|X||||||
|REQ-007|||||||||X||||
|REQ-008|||||X|||||||X|

<a name="перечень-задач-проекта"></a>Матрица, приведённая в таблице 4, позволяет убедиться, что каждое требование проверяется хотя бы одним тестовым сценарием, а также выявить потенциальные пробелы в тестировании. В данном проекте все требования имеют соответствующие тестовые сценарии, что обеспечивает полноту проверки функциональности интернет-витрины.

Таблица 5 – Перечень задач проекта 

|№ истории|№ задачи|Описание задачи|Приоритет|Трудоемкость (ч)|
| :- | :- | :- | :- | :- |
|US-001|T-001|Разработка API и компонентов навигации по категориям|Высокий|13|
|US-002|T-002|Разработка API и интерфейса детальной информации о товаре|Высокий|23|
|US-003|T-003|Разработка функционала добавления новых товаров|Высокий|29|
|US-004|T-004|Разработка функционала редактирования товаров|Высокий|16|
|US-005|T-005|Реализация фильтрации и сортировки товаров|Высокий|27|
|US-006|T-006|Разработка функционала корзины покупок|Высокий|29|
|US-007|T-007|Разработка системы оформления заказов|Высокий|36|
|US-008|T-009|Разработка системы аналитики продаж|Средний|24|
|US-009|T-010|Разработка системы управления пользователями и правами|Высокий|22|

<a name="_toc196130514"></a><a name="_toc196130590"></a><a name="реализация-серверной-части"></a>Перечень задач проекта из таблицы 5 представляет собой конкретные работы, необходимые для реализации пользовательских историй. Каждая задача связана с соответствующей историей, имеет оценку трудоемкости и приоритет, что позволяет эффективно планировать ресурсы и контролировать прогресс разработки. Общая трудоемкость проекта составила 237 человеко-часов, при этом наиболее сложными задачами оказались разработка системы оформления заказов и реализация функционала добавления товаров. Этот список задач служил основой для формирования итераций разработки и распределения работ в ходе проекта.


## <a name="_toc196173519"></a>1.3. Реализация серверной части
Серверная часть нужна для обработки данных, управления заказами и взаимодействия с клиентами. Она обеспечивает хранение информации о товарах, их доступности и ценах, обрабатывает заказы, взаимодействует с базой данных. Серверная часть также отвечает за безопасность данных. Без неё сайт не сможет динамически обновлять информацию, обрабатывать запросы пользователей и обеспечивать функционал интернет-магазина.
## <a name="_toc196130515"></a><a name="_toc196130591"></a><a name="_toc196173520"></a><a name="структура-серверного-приложения"></a>**1.3.1. Структура серверной части**
Серверная часть интернет-витрины “Дому мебель” разработана на базе Node.js с использованием фреймворка Express.js. Архитектура построена по принципу многослойной организации с четким разделением ответственности между компонентами:

1. Уровень представления (controllers) - обработка HTTP-запросов и формирование ответов;
1. Уровень бизнес-логики (services) - реализация бизнес-правил и основной логики приложения;
1. Уровень доступа к данным (repositories) - взаимодействие с базой данных;
1. Домен-модели (models) - сущности предметной области и их поведение.

Такая структура обеспечивает высокую модульность, тестируемость и возможность замены компонентов без влияния на другие части системы.

Для организации взаимодействия между слоями используется внедрение зависимостей через инверсию управления (IoC), что позволяет снизить связность компонентов и улучшить тестируемость системы.
## <a name="_toc196130516"></a><a name="_toc196130592"></a><a name="_toc196173521"></a><a name="реализация-rest-api"></a>**1.3.2. Реализация REST API**
REST API интернет-витрины обеспечивает взаимодействие между клиентским приложением и сервером. При разработке API были соблюдены основные принципы REST-архитектуры:

- Использование HTTP-методов в соответствии с их семантикой (GET, POST, PUT, DELETE);
- Ресурсо-ориентированный подход к проектированию эндпоинтов;
- Единообразие интерфейса;
- Отсутствие состояния (statelessness);

Примеры основных эндпоинтов API:

1. Получение списка категорий:
- GET /api/categories - получение всех категорий;
- GET /api/categories/:id - получение категории по идентификатору;
- GET /api/categories/:id/subcategories - получение подкатегорий товаров;
- GET /api/categories/:id/subcategories/:id - получение подкатегорий товаров по идентификатору.
1. Работа с товарами:
- GET /api/products - получение списка товаров;
- GET /api/products/:id - получение полной информации о товаре;
- POST /api/products - добавление нового товара (требует аутентификации и наличия прав администратора);
- PUT /api/products/:id - обновление существующего товара (требует аутентификации и наличия прав администратора);
- DELETE /api/products/:id - удаление товара (требует аутентификации и наличия прав администратора).
1. Административные эндпоинты:
- POST /api/auth/login - аутентификация администратора;
- GET /api/admin/dashboard - получение статистики для панели администратора;
- POST /api/admin/products/bulk - массовое обновление товаров.

Для документирования API используется Swagger, что обеспечивает удобство разработки и интеграции клиентской части с серверной.
## <a name="_toc196130517"></a><a name="_toc196130593"></a><a name="_toc196173522"></a><a name="реализация-бизнес-логики"></a>**1.3.3. Реализация бизнес-логики**
В данном разделе рассматривается реализация основных бизнес-процессов интернет-витрины мебельного магазина “Дому мебель”.

<a name="обработка-запросов-к-каталогу-товаров"></a>Обработка запросов к каталогу товаров является одним из центральных элементов бизнес-логики системы. Основная задача данного процесса — предоставление пользователю актуальной информации о товарах с учетом примененных фильтров и условий сортировки.

Реализация обработки запросов производится с использованием сервисного слоя, который обрабатывает параметры запроса, выполняет валидацию и делегирует фактическое получение данных репозиторию.

<a name="валидация-данных-товаров"></a>Для обеспечения целостности и корректности данных в системе реализован комплексный механизм валидации данных о товарах. Этот механизм применяется как при создании новых товаров, так и при обновлении существующих.

Для реализации валидации используется подход с интерфейсом Validator, который предоставляет единый способ проверки данных различных типов. Пример реализации ProductValidator представлен в Приложении А.1.1.

<a name="фильтрация-и-сортировка-товаров"></a>Для обеспечения удобного поиска товаров пользователями реализован мощный механизм фильтрации и сортировки. Данный механизм построен с использованием паттерна “Стратегия”, что позволяет легко добавлять новые критерии фильтрации и способы сортировки. Пример реализации стратегий фильтрации и сортировки представлен в Приложении А.1.1.

Использование паттерна “Стратегия” позволяет изолировать логику различных стратегий фильтрации: легко добавлять новые критерии фильтрации без изменения существующего кода; Комбинировать различные фильтры для получения более точных результатов; Эффективно тестировать каждую стратегию фильтрации в изоляции.

<a name="реализация-корзины-покупок"></a>Интернет-витрина “Дому мебель” включает в себя функциональность корзины покупок, которая позволяет пользователям сохранять выбранные товары и формировать заказы. Учитывая специфику мебельного магазина, в корзине реализованы дополнительные возможности:

- Сохранение выбранных товаров;
- Расчет стоимости доставки в зависимости от состава корзины;
- Сохранение состояния корзины между сессиями пользователя.

Реализация корзины произведена с использованием паттернов “Репозиторий” и “Фабрика”, что обеспечивает гибкость в выборе способа хранения данных в зависимости от статуса пользователя. Примеры реализации представлены в Приложении А.1.1.

<a name="x666be60e91a324e039b8daf1e946a9a2523cdb2"></a>В процессе разработки бизнес-логики интернет-витрины были использованы различные паттерны проектирования, которые позволили создать гибкую и расширяемую архитектуру системы:

1. Репозиторий - для абстрагирования доступа к данным;
1. Стратегия - для реализации различных алгоритмов фильтрации и сортировки;
1. Фабрика - для создания объектов без указания конкретных классов;
1. Адаптер - для преобразования интерфейсов внешних сервисов;

Примеры реализации этих паттернов представлены в Приложении А.1.1.

<a name="механизмы-обеспечения-безопасности"></a>В рамках бизнес-логики системы были реализованы механизмы обеспечения безопасности, которые защищают данные пользователей и операционную целостность системы:

1. Валидация входных данных - предотвращение атак типа инъекций и XSS;
1. Контроль доступа - разграничение прав доступа к различным функциям системы;
1. Защита от CSRF-атак - использование токенов для защиты от подделки межсайтовых запросов;
1. Ограничение частоты запросов - защита от DoS-атак.

Примеры реализации механизмов безопасности представлены в Приложении А.1.1.
## <a name="_toc196130518"></a><a name="_toc196130594"></a><a name="_toc196173523"></a><a name="взаимодействие-с-базой-данных"></a>**1.3.4. Взаимодействие с базой данных**
<a name="реализация-слоя-доступа-к-данным"></a>Взаимодействие с базой данных организовано через слой доступа к данным, реализованный по паттерну “Репозиторий”. Для каждой сущности создан отдельный репозиторий, отвечающий за операции CRUD (Create, Read, Update, Delete).

Для обеспечения атомарности операций с базой данных реализован паттерн “Unit of Work”, который управляет транзакциями. Пример реализации этого паттерна представлен в Приложении А.1.3.

<a name="sql-запросы-для-основных-операций"></a>Для оптимального взаимодействия с базой данных разработаны эффективные SQL-запросы, учитывающие специфику предметной области и обеспечивающие высокую производительность системы. Примеры SQL-запросов для работы с товарами представлены в Приложении А.1.2.

Особое внимание уделено: минимизации количества запросов к базе данных через объединение данных; использованию параметризованных запросов для предотвращения SQL-инъекций; оптимизации запросов для улучшения производительности.

<a name="xf7b657bee8ed8be02c957229aa9ad0f70b70554"></a>Для обеспечения высокой производительности системы при работе с большими объемами данных реализованы следующие оптимизации:

1. Создание индексов (Приложение А.1.4) - для ускорения поиска и сортировки данных;
1. Использование материализованных представлений (Приложение А.1.5.) - для кэширования часто запрашиваемых данных и снижения нагрузки на базу данных. 
1. Оптимизация структуры таблиц - правильный выбор типов данных и нормализация для оптимального хранения информации;
1. Разделение таблиц - для повышения производительности запросов к большим таблицам.

Реализованные оптимизации позволили значительно улучшить время отклика системы даже при большом количестве товаров и одновременных запросах.
## <a name="_toc196130519"></a><a name="_toc196130595"></a><a name="_toc196173524"></a><a name="обработка-ошибок-и-логирование"></a>**1.3.5. Обработка ошибок и логирование**
<a name="централизованная-обработка-ошибок"></a>Для обеспечения надежности и отказоустойчивости системы реализована централизованная обработка ошибок, которая:

1. Классифицирует ошибки по типам:
- Ошибки валидации (ValidationError) - связанные с некорректными входными данными;
- Ошибки бизнес-логики (BusinessLogicError) - связанные с нарушением бизнес-правил;
- Ошибки доступа к данным (DataAccessError) - связанные с проблемами взаимодействия с базой данных;
- Ошибки аутентификации и авторизации (AuthError) - связанные с правами доступа;
- Системные ошибки (SystemError) - связанные с инфраструктурой и внешними сервисами.
1. Обрабатывает ошибки на уровне middleware Express.js, что позволяет:
- Формировать единообразные ответы с HTTP-статусами, соответствующими типу ошибки;
- Скрывать технические детали ошибок от пользователей;
- Логировать ошибки для последующего анализа.

<a name="система-логирования"></a>Для мониторинга работы системы и оперативного выявления проблем реализована система логирования на базе библиотеки Winston, которая обеспечивает:

1. Уровни логирования (error, warn, info, debug) для разделения сообщений по степени важности;
1. Различные транспорты для записи логов:
- Файловая система - для постоянного хранения;
- Консоль - для разработки и отладки;
- Сервис Sentry - для централизованного сбора и анализа ошибок.
1. Структурированный формат логов в формате JSON для удобства анализа;
1. Контекстное логирование с привязкой к запросам через уникальный идентификатор (correlation ID).

<a name="реализация-клиентской-части"></a><a name="_toc196130520"></a><a name="_toc196130596"></a><a name="_toc196173525"></a>
## 1\.4. Реализация клиентской части
Клиентская часть интернет-витрины “Дому мебель” реализована на базе современной библиотеки React с применением архитектурного подхода Feature-Sliced Design (FSD). Данная архитектура предполагает организацию кода по слоям и функциональным модулям (фичам), что обеспечивает высокую поддерживаемость и масштабируемость системы.
## <a name="_toc196130521"></a><a name="_toc196130597"></a><a name="_toc196173526"></a><a name="структура-клиентского-приложения"></a>**1.4.1. Структура клиентского приложения**
<a name="организация-кода-по-методологии-fsd"></a>Структура проекта организована по следующим слоям, приведённым в таблице 6.

Таблица 6 – Архитектура клиентской части

|`  `Слой|Описание|
| :- | :- |
|`  `app|Корневой слой, содержащий сетап приложения, провайдеры, глобальные стили и типы.|
|`  `processes|Бизнес-процессы, связывающие несколько функциональных модулей.|
|`  `pages|Композиция виджетов для конкретных страниц приложения.|
|`  `widgets|Композиция компонентов и сущностей для решения бизнес-задач.|
|`  `features|Взаимодействие с пользователем, реализация пользовательских сценариев.|
|`  `entities|Бизнес-сущности, используемые в приложении.|
|`  `shared|Переиспользуемый код, не имеющий привязки к бизнес-логике.|

Каждый слой и модуль имеет строго определенные зависимости, что позволяет избежать циклических зависимостей и обеспечивает прозрачность архитектуры.

<a name="организация-состояния-приложения"></a>Управление состоянием приложения организовано с использованием:

- Redux - для обеспечения глобального состояния приложения;
- React Context - для состояния, которое должно быть доступно в определенной части приложения;
- React hooks - для локального состояния компонентов.

Такой подход обеспечивает: Предсказуемость изменения состояния; Возможность отладки и инспекции состояния; Оптимальную производительность за счет минимизации перерисовок.

<a name="реализация-компонентного-подхода"></a>При разработке клиентской части применен компонентный подход (таблица 7), обеспечивающий модульность и переиспользуемость кода.

Таблица 7 – Общие компоненты клиенской части

|Компонент|Описание|Реализация|
| :- | :- | :- |
|Компонент     маршрутизации приложения|Обеспечивает навигацию между страницами и защиту приватных маршрутов.|Приложения А.2.1, А.2.2|
|Компонент главного меню|Обеспечивает навигацию по основным разделам сайта.|Приложение А.2.3|
|Компонент хлебных крошек|Указывает текущее местоположение пользователя в структуре сайта.|Приложение А.2.4|
|Компонент каталога товаров|Отображает товары с возможностью фильтрации и сортировки.|Приложение А.2.6|
|Компонент карточки товара|Представляет информацию о товаре в компактном виде.|Приложение А.2.10|
## <a name="_toc196130522"></a><a name="_toc196130598"></a><a name="_toc196173527"></a><a name="реализация-маршрутизации-и-навигации"></a>**1.4.2. Реализация маршрутизации и навигации**
Маршрутизация в приложении реализована с использованием библиотеки React Router v6, которая обеспечивает навигацию между различными разделами сайта без перезагрузки страницы.

<a name="структура-маршрутов"></a>Структура маршрутов приложения включает: 

- Публичные маршруты (главная, каталог, страница товара, контакты, о нас);
- Административные маршруты (дашборд, управление товарами, категориями, заказами);
- Специальные маршруты (страница ошибки 404).

Реализация компонентов маршрутизации представлена в Приложении А.2.1.

<a name="защита-административных-маршрутов"></a>Для обеспечения безопасного доступа к административным функциям реализован компонент защищенного маршрута (Приложении А.2.2), который проверяет аутентификацию пользователя. 

<a name="компоненты-навигации"></a>Для обеспечения удобной навигации пользователям был реализован компонент «хлебные крошки» (Приложении А.2.4). Компонент отображает текущее положение в иерархии сайта и позволяет осуществлять навигацию (Рисунок 1).

![](Aspose.Words.76a0fb4b-4c34-4df3-879a-d760e4bd97f1.001.png)

Рисунок 1 - Хлебные крошки

<a name="x42abf89dd46d38ac6a5073c80ffcc79adb9eaa7"></a>Для обеспечения возможности сохранения и передачи состояния фильтров и сортировки реализован механизм работы с параметрами URL, что позволяет сохранять выбранные фильтры при обновлении страницы и делиться ссылками на каталог с заданными параметрами фильтрации. Кодовая реализация работы с параметрами URL представлена в Приложении А.2.5.
## <a name="_toc196130523"></a><a name="_toc196130599"></a><a name="_toc196173528"></a><a name="разработка-пользовательского-интерфейса"></a>**1.4.3. Разработка пользовательского интерфейса**
<a name="реализация-дизайн-системы"></a>Для обеспечения единообразия и согласованности пользовательского интерфейса разработана дизайн-система, включающая:

- Цветовая палитра (Приложение А.2.7) - определяет основные и вспомогательные цвета интерфейса;
- Типографика (Приложение А.2.8)- определяет шрифты, размеры и стили текста;
- Базовые компоненты - набор переиспользуемых компонентов: Кнопки разных типов и стилей (Приложение А.2.9); Карточки (Приложение А.2.10); Поля ввода формы; Переключатели, чекбоксы, радиокнопки; Иконки; Уведомления и модальные окна.

<a name="обеспечение-доступности-интерфейса"></a>Для обеспечения доступности интерфейса для всех групп пользователей, включая пользователей с ограниченными возможностями, реализованы следующие меры:

- Семантическая разметка - использование соответствующих HTML-тегов для структурирования контента;
- ARIA-атрибуты - для улучшения доступности динамических компонентов;
- Управление с клавиатуры - для всех интерактивных элементов;
- Оптимизация для screen reader - альтернативные текстовые описания для изображений;
- Достаточные цветовые контрасты - для улучшения читаемости текста.

<a name="реализация-интерфейсов-основных-разделов"></a>Реализованы пользовательские интерфейсы для всех основных разделов сайта: главная страница; каталог товаров; страница товара; административная панель.
## <a name="_toc196130524"></a><a name="_toc196130600"></a><a name="_toc196173529"></a><a name="реализация-адаптивного-дизайна"></a>**1.4.4. Реализация адаптивного дизайна**
<a name="реализация-адаптивной-сетки"></a>Для обеспечения корректного отображения на различных устройствах реализована адаптивная сетка на основе CSS Grid и Flexbox (Приложение А.2.11). Контрольные точки (breakpoints) представлены в таблице 8. 

Таблица 8 – Границы контрольных точек экранов.

|<a name="адаптивные-компоненты"></a>  Размер|<p>Разрешение </p><p>(min-width)</p>|Описание|
| :- | :- | :- |
|`  `XS|< 576px|Мобильные устройства|
|`  `SM|≥ 576px|Смартфоны в горизонтальной ориентации|
|`  `MD|≥ 768px|Планшеты|
|`  `LG|≥ 992px|Десктопы|
|`  `XL|≥ 1200px|Широкие экраны|
|`  `XXL|≥ 1400px|Очень широкие экраны|

Реализованы адаптивные компоненты, которые изменяют свой внешний вид и поведение в зависимости от размера экрана. Адаптивное главное меню - трансформируется в бургер-меню на мобильных устройствах (рисунок 2).

![](Aspose.Words.76a0fb4b-4c34-4df3-879a-d760e4bd97f1.002.png) ![](Aspose.Words.76a0fb4b-4c34-4df3-879a-d760e4bd97f1.003.png)

Рисунок 2 – Адаптивное главное меню

Адаптивная сетка каталога - изменяет количество карточек в ряду в зависимости от ширины экрана (рисунок 3)

![](Aspose.Words.76a0fb4b-4c34-4df3-879a-d760e4bd97f1.004.png)

Рисунок 3 – Пример адаптивной сетки каталога

- Адаптивные изображения - загружает изображения разного размера в зависимости от разрешения устройства. Кодовая реализация адаптивных изображений представлена в Приложении А.2.12.

<a name="x00b98b2d13b42216f993b22054339535a76ce9c"></a>Для обеспечения быстрой загрузки и отзывчивости интерфейса на мобильных устройствах реализованы следующие оптимизации:

- Ленивая загрузка изображений (lazy loading) - изображения загружаются только при появлении в видимой области;
- Виртуализация списков (Приложение А.2.13) - для отображения большого количества товаров без потери производительности;
- Оптимизация размера бандла - разделение кода на чанки для оптимальной загрузки.
- <a name="тестирование-системы"></a>
## <a name="_toc196130525"></a><a name="_toc196130601"></a><a name="_toc196173530"></a>1.5. Тестирование системы
<a name="методология-тестирования"></a>При разработке интернет-витрины “Дому мебель” был применен комплексный подход к тестированию, включающий различные виды тестов:

- Модульные (unit) тесты - проверка работы отдельных компонентов в изоляции;
- Интеграционные тесты - проверка взаимодействия между компонентами;
- Функциональные тесты - проверка соответствия функциональным требованиям;
- Тесты пользовательского интерфейса - проверка корректности отображения и взаимодействия с UI;
- Нагрузочные тесты - проверка производительности системы под нагрузкой.

Для реализации тестов использовались следующие инструменты: Jest - для модульных и интеграционных тестов; React Testing Library - для тестирования React-компонентов; Cypress - для функциональных тестов и тестов пользовательского интерфейса; k6 - для нагрузочного тестирования.

<a name="модульное-тестирование-компонентов"></a>Модульные тесты были разработаны для ключевых компонентов системы: - Компоненты бизнес-логики серверной части - Функции фильтрации и сортировки - Утилиты и хелперы - React-компоненты.

Покрытие кода модульными тестами составило 85%, что обеспечивает высокий уровень надежности компонентов.

<a name="интеграционное-тестирование"></a>Интеграционные тесты были направлены на проверку корректности взаимодействия между различными компонентами системы: Взаимодействие контроллеров с сервисами и репозиториями; Корректность работы бизнес-правил с использованием реальной базы данных; Взаимодействие между компонентами пользовательского интерфейса.

<a name="x88393b31b327ac639d764ab5c25efcb4571b4fc"></a>Для тестирования пользовательского интерфейса были разработаны сценарии, охватывающие основные пользовательские истории: Просмотр каталога товаров; Поиск и фильтрация товаров; Оформление заказа; Административные функции.

Тесты пользовательского интерфейса позволили выявить и исправить проблемы с удобством использования и доступностью интерфейса.

<a name="нагрузочное-тестирование"></a>Нагрузочное тестирование позволило оценить производительность системы в условиях высокой нагрузки: Тестирование с имитацией до 1000 одновременных пользователей; Проверка скорости отклика API при высокой нагрузке; Оценка производительности базы данных при интенсивных запросах.

Результаты нагрузочного тестирования показали, что система способна обрабатывать до 500 одновременных пользователей с сохранением среднего времени отклика в пределах 300 миллисекунд.

<a name="xbe7420ec04ad3f6a41eb2128c83900e3288f242"></a>В ходе тестирования было выявлено и исправлено 87 ошибок различного уровня критичности: 12 критических ошибок (влияющих на основные функции системы); 35 значительных ошибок (ухудшающих пользовательский опыт); 40 незначительных ошибок (не влияющих на основные функции). Статистика ошибок по компонентам системы представлена в таблице 9.

<a name="развертывание-и-внедрение"></a>Таблица 9 - Ошибки по компонентам системы

|Компонент системы|Количество ошибок|
| :- | :- |
|Серверная часть|32 ошибки|
|Клиентская часть|42 ошибки|
|База данных|8 ошибок|
|Инфраструктура|5 ошибок|



<a name="_toc196130526"></a><a name="_toc196130602"></a>
## <a name="_toc196173531"></a>1.6. Развертывание и внедрение
<a name="настройка-окружения-для-развертывания"></a>Для размещения интернет-витрины "Дому мебель" был проведен тщательный анализ представленных на рынке хостинг-провайдеров. 

В результате сравнительного анализа нескольких вариантов (таблица 10) был выбран облачный хостинг DigitalOcean, предоставляющий оптимальное соотношение цены и качества, а также необходимые технические возможности для развертывания проекта.

Таблица 10 - Сравнительный анализ хостинг-провайдеров

|Критерий|DigitalOcean|Heroku|AWS|Timeweb|
| :- | :- | :- | :- | :- |
|Стоимость (руб./мес.)|1000|700-2500|1200-3500|500-1500|
|Производительность|Высокая|Средняя|Высокая|Средняя|
|Поддержка Node.js|Да|Да|Да|Да|
|Поддержка PostgreSQL|Да|Да|Да|Да|
|Масштабируемость|Высокая|Средняя|Высокая|Низкая|
|Техническая поддержка|24/7|Ограниченная|24/7|Рабочие часы|
|SSL-сертификаты|Бесплатно|Платно|Платно|Платно|

После выбора хостинг-провайдера было выполнено конфигурирование сервера и настройка необходимого окружения: 

1\. Установка и настройка операционной системы Ubuntu Server 20.04 LTS; 

2\. Установка Node.js версии 16.x и npm; 

3\. Установка и настройка базы данных PostgreSQL 13; 

4\. Настройка веб-сервера Nginx в качестве обратного прокси;

5\. Настройка системы управления процессами PM2;

6\. Конфигурирование брандмауэра и SSL-сертификатов<a name="процесс-развертывания-приложения"></a>;

Процесс развертывания интернет-витрины включал следующие этапы: 

1\. Настройка CI/CD с использованием GitHub Actions;

2\. Развертывание серверной части; 

3\. Развертывание клиентской части; 

4\. Настройка мониторинга и логирования<a name="мониторинг-и-поддержка-системы"></a>.

<a name="обучение-персонала"></a>Для эффективного использования интернет-витрины сотрудниками “Дому мебель” был проведён мастер-класс по работе с панелью администратора и навигацией по сайту.

<a name="оценка-результатов-разработки"></a>
## <a name="_toc196130527"></a><a name="_toc196130603"></a><a name="_toc196173532"></a>1.7. Оценка результатов разработки
<a name="анализ-соответствия-системы-требованиям"></a>По завершении разработки был проведен анализ соответствия интернет-витрины изначальным требованиям: Реализованы 92% функциональных требований; Выполнены все нефункциональные требования к производительности и безопасности; 8% требований отложены для реализации во второй фазе проекта.

<a name="анализ-пользовательского-опыта"></a>Тестирование с участием 15 потенциальных клиентов показало: 87% пользователей положительно оценили удобство интерфейса; 93% успешно выполнили основные сценарии использования; Средняя оценка удобства использования составила 4.6 из 5.

<a name="оценка-производительности-системы"></a>Анализ производительности показал высокие показатели системы:

- Время загрузки страниц: 1.2-1.8 секунды;
- Среднее время отклика API: 120 миллисекунд;
- Стабильная работа под нагрузкой до 500 одновременных пользователей.

<a name="экономическая-эффективность-разработки"></a>Финансовый анализ показал: 

Для оценки экономической эффективности разработки и внедрения интернет-витрины "Дому мебель" был проведен финансовый анализ:

1\. Затраты на разработку:

- Трудозатраты: 480 человеко-часов × 500 руб./час = 240000 руб.
- Хостинг и инфраструктура (на год): 12000 руб.
- Дополнительные расходы (доменное имя, SSL-сертификат): 3000 руб.
- Общие затраты на разработку и внедрение: 255000 руб.

2\. Экономический эффект от внедрения: 

- Прогнозируемое увеличение продаж на 15% благодаря расширению клиентской базы;
- Экономия затрат на персонал за счет автоматизации процессов: 20000 руб./мес;
- Снижение затрат на маркетинговые материалы: 10000 руб./мес; 
- Общий экономический эффект за год: 360000 руб.

3\. Срок окупаемости:

- Расчет срока окупаемости: 255000 / (360000 / 12) = 8.5 месяцев;
- С учетом рисков и неопределенностей расчетный срок окупаемости составляет 9-10 месяцев

Проведенный анализ показывает, что разработка и внедрение интернет-витрины "Дому мебель" является экономически эффективным решением, которое окупится менее чем за год и будет приносить стабильный экономический эффект в долгосрочной перспективе.


# <a name="_toc196173533"></a>Список использованных источников
1. Бэнкс А., Порселло Е. React и Redux. Функциональная веб-разработка. — СПб.: Питер, 2020. — 336 с.
1. Симпсон К. Вы не знаете JS: ES6 и не только. — СПб.: Питер, 2019. — 496 с.
1. Браун И. Веб-разработка с применением Node и Express. Полноценное использование стека JavaScript. — СПб.: Питер, 2020. — Изд. 2-е. — 336 с.
1. Кириченко А., Хрусталев А. HTML5 + CSS3. Основы современного веб-дизайна. — СПб.: Наука и Техника, 2018. — 352 с.
1. Дакетт Д. HTML и CSS. Разработка и дизайн веб-сайтов. — М.: Эксмо, 2019. — 480 с.
1. Гринберг М. Разработка веб-приложений с использованием Flask на языке Python. — М.: ДМК Пресс, 2018. — 272 с.
1. Ньюман С. Создание микросервисов. — СПб.: Питер, 2019. — 304 с.
1. Коберн А. Современные методы описания функциональных требований к системам. — М.: Лори, 2019. — 288 с.
1. Вигерс К., Битти Д. Разработка требований к программному обеспечению. — М.: Русская редакция, 2020. — 736 с.
1. Крокфорд Д. JavaScript: сильные стороны. — СПб.: Питер, 2020. — 176 с.
1. Бек К. Экстремальное программирование: разработка через тестирование. — СПб.: Питер, 2017. — 224 с.
1. Расс М. Адаптивный дизайн. Делаем сайты для любых устройств. — СПб.: Питер, 2019. — 288 с.
1. Мейер Э. CSS — каскадные таблицы стилей. Подробное руководство. — М.: Символ-Плюс, 2019. — 576 с.
1. Фаулер М., Райс Д., Фоммел М., Хайет Э., Ми Р., Стаффорд Р. Шаблоны корпоративных приложений. — М.: Вильямс, 2020. — 544 с.
1. Мэтью Д. HTML5. Разработка приложений для мобильных устройств. — СПб.: Рид Групп, 2019. — 480 с.
1. Кент Б. Экстремальное программирование. Планирование. — СПб.: Питер, 2019. — 224 с.
1. Макконнелл С. Совершенный код. Мастер-класс. — М.: Русская редакция, 2019. — 896 с.

<a name="_toc196130528"></a><a name="_toc196130604"></a>
# <a name="_toc196173534"></a>Приложение А. Листинги исходного кода
В данном приложении представлены листинги кода, написанные при разработке интернет-витрины "Дому мебель".
## <a name="_toc196130529"></a><a name="_toc196130605"></a><a name="_toc196173535"></a>А.1. Примеры серверной части
`	`В данной главе приложения представлены листинги кода серверной части сайта. Код отвечает за реализацию бизнес-логики, работу с базой данных и обработку пользовательских запросов.
## <a name="_toc196130530"></a><a name="_toc196130606"></a><a name="_toc196173536"></a>**А.1.1. Доменная модель товара**
~~~ typescript
// Пример доменной модели товара
export class Product {
  private id: string;
  private title: string;
  private description: string;
  private price: Money;
  private category: Category;
  private attributes: ProductAttribute[];
  private images: ProductImage[];
  private availabilityStatus: AvailabilityStatus;
  
  constructor(props: ProductProps) {
    // Валидация входных данных
    this.validateProperties(props);
  
    // Инициализация свойств
    this.id = props.id;
    this.title = props.title;
    this.description = props.description;
    this.price = props.price;
    this.category = props.category;
    this.attributes = props.attributes || [];
    this.images = props.images || [];
    this.availabilityStatus = props.availabilityStatus || AvailabilityStatus.IN_STOCK;
  }
  
  // Бизнес-методы
  public isAvailable(): boolean {
    return this.availabilityStatus === AvailabilityStatus.IN_STOCK;
  }
  
  public applyDiscount(percentage: number): void {
    if (percentage <= 0 || percentage >= 100) {
      throw new InvalidDiscountError('Процент скидки должен быть в диапазоне от 1 до 99');
    }
  
    this.price = this.price.applyDiscount(percentage);
  }
  
  public changeAvailability(status: AvailabilityStatus): void {
    this.availabilityStatus = status;
  }
  
  // Методы валидации
  private validateProperties(props: ProductProps): void {
    if (!props.title || props.title.trim().length < 3) {
      throw new ValidationError('Название товара должно содержать минимум 3 символа');
    }
  
    if (!props.price || props.price.getValue() <= 0) {
      throw new ValidationError('Цена товара должна быть положительным числом');
    }
  
    if (!props.category) {
      throw new ValidationError('Товар должен относиться к категории');
    }
  }
}
~~~
## <a name="_toc196130531"></a><a name="_toc196130607"></a><a name="_toc196173537"></a>**А.1.2. SQL запросы репозитория товаров**
~~~ typescript
// Пример SQL запросов для работы с товарами
// Формирование сортировки
const sortField = this.getSafeColumnName(sorting.field);
const sortDirection = sorting.direction === 'ASC' ? 'ASC' : 'DESC';

// Получение товаров
const query = `
  SELECT 
    p.id, p.title, p.description, p.price, p.currency, p.availability_status,
    c.id as category_id, c.name as category_name, c.parent_id as category_parent_id
  FROM products p
  LEFT JOIN categories c ON p.category_id = c.id
  WHERE p.category_id = ANY($1) AND p.deleted_at IS NULL
  ORDER BY p.${sortField} ${sortDirection}
  LIMIT $2 OFFSET $3
`;

const result = await this.dbConnection.query(query, [categoryIds, pagination.limit, offset]);

// Получение идентификаторов товаров
const productIds = result.rows.map(row => row.id);

if (productIds.length === 0) {
  return [];
}

// Получение атрибутов для всех товаров одним запросом
const attributesQuery = `
  SELECT pa.product_id, a.id, a.name, pa.value
  FROM product_attributes pa
  JOIN attributes a ON pa.attribute_id = a.id
  WHERE pa.product_id = ANY($1)
`;

const attributesResult = await this.dbConnection.query(attributesQuery, [productIds]);

// Получение изображений для всех товаров одним запросом
const imagesQuery = `
  SELECT product_id, id, url, alt, is_main
  FROM product_images
  WHERE product_id = ANY($1)
  ORDER BY is_main DESC, sort_order ASC
`;

const imagesResult = await this.dbConnection.query(imagesQuery, [productIds]);

// Группировка атрибутов и изображений по ID товара
const attributesByProductId = this.groupByProductId(attributesResult.rows);
const imagesByProductId = this.groupByProductId(imagesResult.rows);

// Маппинг данных из БД в доменные модели
return result.rows.map(row => 
  this.mapToProduct(
    row, 
    attributesByProductId[row.id] || [], 
    imagesByProductId[row.id] || []
  )
);
~~~
## <a name="_toc196130532"></a><a name="_toc196130608"></a><a name="_toc196173538"></a>**А.1.3. Реализация паттерна Unit of Work**
~~~ typescript
@injectable()
export class UnitOfWork implements IUnitOfWork {
  constructor(
    @inject(TYPES.DatabaseConnection) private dbConnection: DatabaseConnection,
    @inject(TYPES.Logger) private logger: ILogger
  ) {}
  
  public async begin(): Promise<void> {
    await this.dbConnection.query('BEGIN');
  }
  
  public async commit(): Promise<void> {
    await this.dbConnection.query('COMMIT');
  }
  
  public async rollback(): Promise<void> {
    await this.dbConnection.query('ROLLBACK');
  }
  
  public async withTransaction<T>(callback: () => Promise<T>): Promise<T> {
    try {
      await this.begin();
      const result = await callback();
      await this.commit();
      return result;
    } catch (error) {
      await this.rollback();
      this.logger.error('Transaction rolled back', { error });
      throw error;
    }
  }
}
~~~
## <a name="_toc196130533"></a><a name="_toc196130609"></a><a name="_toc196173539"></a>**А.1.4. SQL индексы для оптимизации производительности**
~~~ sql
-- Индексы для таблицы products
CREATE INDEX idx_products_category_id ON products(category_id);
CREATE INDEX idx_products_price ON products(price);
CREATE INDEX idx_products_availability_status ON products(availability_status);
CREATE INDEX idx_products_created_at ON products(created_at);

-- Индексы для атрибутов товаров
CREATE INDEX idx_product_attributes_product_id ON product_attributes(product_id);
CREATE INDEX idx_product_attributes_attribute_id ON product_attributes(attribute_id);
CREATE INDEX idx_product_attributes_value ON product_attributes(value);

-- Составной индекс для оптимизации запросов с фильтрацией
CREATE INDEX idx_products_category_status_price ON products(category_id, availability_status, price);
~~~
## <a name="_toc196130534"></a><a name="_toc196130610"></a><a name="_toc196173540"></a>**А.1.5. SQL материализованные представления**
~~~ sql
-- Материализованное представление для каталога товаров
CREATE MATERIALIZED VIEW product_catalog AS
SELECT 
  p.id, 
  p.title, 
  p.description, 
  p.price, 
  p.currency,
  p.availability_status,
  p.category_id,
  c.name as category_name,
  pi.url as main_image_url
FROM products p
JOIN categories c ON p.category_id = c.id
LEFT JOIN (
  SELECT DISTINCT ON (product_id) product_id, url
  FROM product_images
  WHERE is_main = true
  ORDER BY product_id, is_main DESC
) pi ON p.id = pi.product_id
WHERE p.deleted_at IS NULL
ORDER BY p.created_at DESC;

-- Индекс для материализованного представления
CREATE INDEX idx_product_catalog_category_id ON product_catalog(category_id);
CREATE INDEX idx_product_catalog_price ON product_catalog(price);

-- Функция для обновления материализованного представления
CREATE OR REPLACE FUNCTION refresh_product_catalog()
RETURNS TRIGGER AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY product_catalog;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Триггер для автоматического обновления материализованного представления
CREATE TRIGGER refresh_product_catalog_trigger
AFTER INSERT OR UPDATE OR DELETE ON products
FOR EACH STATEMENT
EXECUTE FUNCTION refresh_product_catalog();
~~~

<a name="_toc196130535"></a><a name="_toc196130611"></a><a name="_toc196173541"></a>
## А.2. Примеры клиентской части
В данной главе приложения представлены листинги кода клиентской части сайта. Код отвечает за реализацию визуальных элементов сайта, цветовой палитры, стандартного набора шрифтов, а так же за реализацию адаптивной разметки.
## <a name="_toc196130536"></a><a name="_toc196130612"></a><a name="_toc196173542"></a>**А.2.1. Компонент маршрутизации приложения**
~~~ tsx
// app/router/AppRouter.tsx
export const AppRouter: FC = () => {
  return (
    <Routes>
      {/* Публичные маршруты */}
      <Route path="/" element={<MainLayout />}>
        <Route index element={<HomePage />} />
        <Route path="catalog" element={<CatalogPage />} />
        <Route path="catalog/:categoryId" element={<CategoryPage />} />
        <Route path="product/:id" element={<ProductPage />} />
        <Route path="contacts" element={<ContactsPage />} />
        <Route path="about" element={<AboutPage />} />
      </Route>
    
      {/* Административные маршруты с защитой */}
      <Route path="admin" element={<ProtectedRoute><AdminLayout /></ProtectedRoute>}>
        <Route index element={<AdminDashboardPage />} />
        <Route path="products" element={<ProductListPage />} />
        <Route path="products/new" element={<CreateProductPage />} />
        <Route path="products/:id" element={<EditProductPage />} />
        <Route path="categories" element={<CategoriesPage />} />
        <Route path="orders" element={<OrdersPage />} />
      </Route>
    
      {/* Обработка ошибок */}
      <Route path="*" element={<NotFoundPage />} />
    </Routes>
  );
};
~~~
## <a name="_toc196130537"></a><a name="_toc196130613"></a><a name="_toc196173543"></a>**А.2.2. Компонент защищенного маршрута**
~~~ tsx
// app/router/ProtectedRoute.tsx
export const ProtectedRoute: FC<PropsWithChildren> = ({ children }) => {
  const { isAuthenticated, isLoading } = useAuth();
  const location = useLocation();
  
  if (isLoading) {
    return <Loader />;
  }
  
  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }
  
  return <>{children}</>;
};
~~~
## <a name="_toc196130538"></a><a name="_toc196130614"></a><a name="_toc196173544"></a>**А.2.3. Компонент главного меню**
~~~ tsx
// widgets/main-menu/ui/MainMenu.tsx
export const MainMenu: FC = () => {
  const location = useLocation();
  
  const links = [
    { path: '/', label: 'Главная' },
    { path: '/catalog', label: 'Каталог' },
    { path: '/about', label: 'О нас' },
    { path: '/contacts', label: 'Контакты' }
  ];
  
  return (
    <nav className={styles.mainMenu}>
      <ul className={styles.menuList}>
        {links.map(link => (
          <li key={link.path} className={styles.menuItem}>
            <NavLink 
              to={link.path}
              className={({ isActive }) => 
                cn(styles.menuLink, { [styles.active]: isActive })
              }
              end
            >
              {link.label}
            </NavLink>
          </li>
        ))}
      </ul>
    </nav>
  );
};
~~~
## <a name="_toc196130539"></a><a name="_toc196130615"></a><a name="_toc196173545"></a>**А.2.4. Компонент хлебных крошек**
~~~ tsx
// widgets/breadcrumbs/ui/Breadcrumbs.tsx
export const Breadcrumbs: FC<BreadcrumbsProps> = ({ items }) => {
  if (!items.length) {
    return null;
  }
  
  return (
    <nav aria-label="Breadcrumbs" className={styles.breadcrumbs}>
      <ol className={styles.breadcrumbsList}>
        {items.map((item, index) => {
          const isLast = index === items.length - 1;
        
          return (
            <li 
              key={item.path || index} 
              className={styles.breadcrumbsItem}
            >
              {isLast ? (
                <span className={styles.current}>{item.label}</span>
              ) : (
                <Link to={item.path} className={styles.link}>
                  {item.label}
                </Link>
              )}
            
              {!isLast && (
                <span className={styles.separator}>/</span>
              )}
            </li>
          );
        })}
      </ol>
    </nav>
  );
};
~~~
## <a name="_toc196130540"></a><a name="_toc196130616"></a><a name="_toc196173546"></a>**А.2.5. Хук для работы с параметрами фильтрации**
~~~ tsx
// features/catalog-filter/model/useFilterParams.ts
export const useFilterParams = () => {
  const [searchParams, setSearchParams] = useSearchParams();
  
  const currentFilters: FilterState = {
    categoryId: searchParams.get('category') || undefined,
    priceMin: searchParams.get('priceMin') ? 
      Number(searchParams.get('priceMin')) : undefined,
    priceMax: searchParams.get('priceMax') ? 
      Number(searchParams.get('priceMax')) : undefined,
    inStock: searchParams.get('inStock') === 'true',
    sort: searchParams.get('sort') || 'newest',
    page: searchParams.get('page') ? 
      Number(searchParams.get('page')) : 1
  };
  
  const updateFilters = (newFilters: Partial<FilterState>) => {
    const updatedFilters = { ...currentFilters, ...newFilters };
  
    // Сбрасываем страницу при изменении фильтров
    if (newFilters.categoryId !== undefined || 
        newFilters.priceMin !== undefined || 
        newFilters.priceMax !== undefined || 
        newFilters.inStock !== undefined ||
        newFilters.sort !== undefined) {
      updatedFilters.page = 1;
    }
  
    const params = new URLSearchParams();
  
    if (updatedFilters.categoryId) {
      params.set('category', updatedFilters.categoryId);
    }
  
    if (updatedFilters.priceMin) {
      params.set('priceMin', updatedFilters.priceMin.toString());
    }
  
    if (updatedFilters.priceMax) {
      params.set('priceMax', updatedFilters.priceMax.toString());
    }
  
    if (updatedFilters.inStock) {
      params.set('inStock', 'true');
    }
  
    if (updatedFilters.sort !== 'newest') {
      params.set('sort', updatedFilters.sort);
    }
  
    if (updatedFilters.page > 1) {
      params.set('page', updatedFilters.page.toString());
    }
  
    setSearchParams(params);
  };
  
  return { filters: currentFilters, updateFilters };
};
~~~
## <a name="_toc196130541"></a><a name="_toc196130617"></a><a name="_toc196173547"></a>**А.2.6. Компонент страницы каталога**
~~~ tsx
// pages/CatalogPage/ui/CatalogPage.tsx
export const CatalogPage: FC = () => {
  const { filters, updateFilters } = useFilterParams();
  const { data: products, isLoading } = useProducts(filters);
  const { data: categories } = useCategories();
  
  const handleFilterChange = (newFilters: Partial<FilterState>) => {
    updateFilters(newFilters);
  };
  
  const handlePageChange = (page: number) => {
    updateFilters({ page });
    // Прокрутка к началу списка товаров
    window.scrollTo({ top: 0, behavior: 'smooth' });
  };
  
  return (
    <div className={styles.catalogPage}>
      <h1 className={styles.title}>Каталог мебели</h1>
    
      <div className={styles.catalogLayout}>
        <aside className={styles.sidebar}>
          <FilterPanel 
            categories={categories || []}
            initialFilters={filters}
            onFilterChange={handleFilterChange}
          />
        </aside>
      
        <main className={styles.content}>
          <div className={styles.sorting}>
            <SortingPanel 
              value={filters.sort}
              onChange={(sort) => handleFilterChange({ sort })}
            />
          </div>
        
          <CatalogList 
            products={products?.items || []}
            isLoading={isLoading}
          />
        
          {products && products.pagination.totalPages > 1 && (
            <Pagination 
              currentPage={filters.page}
              totalPages={products.pagination.totalPages}
              onPageChange={handlePageChange}
            />
          )}
        </main>
      </div>
    </div>
  );
};
~~~
## <a name="_toc196130542"></a><a name="_toc196130618"></a><a name="_toc196173548"></a>**А.2.7. Стили цветовой палитры приложения**
~~~ scss
// shared/styles/tokens/_colors.scss
$primary: #2a5f8f;
$primary-light: #3a75ab;
$primary-dark: #1a4a78;

$secondary: #f6a623;
$secondary-light: #ffb83d;
$secondary-dark: #e09310;

$text-primary: #333333;
$text-secondary: #666666;
$text-light: #999999;

$background: #ffffff;
$background-light: #f5f7fa;
$background-dark: #e6e9ee;

$border: #dcdfe5;
$border-light: #ebedf0;
$border-dark: #c5c9d0;

$success: #4caf50;
$error: #f44336;
$warning: #ff9800;
$info: #2196f3;
~~~
## <a name="_toc196130543"></a><a name="_toc196130619"></a><a name="_toc196173549"></a>**А.2.8. Стили типографики приложения**
~~~ scss
// shared/styles/tokens/_typography.scss
$font-family-base: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
$font-family-heading: 'Montserrat', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;

$font-size-xs: 0.75rem;    // 12px
$font-size-sm: 0.875rem;   // 14px
$font-size-md: 1rem;       // 16px
$font-size-lg: 1.125rem;   // 18px
$font-size-xl: 1.25rem;    // 20px
$font-size-2xl: 1.5rem;    // 24px
$font-size-3xl: 1.875rem;  // 30px
$font-size-4xl: 2.25rem;   // 36px

$line-height-tight: 1.2;
$line-height-normal: 1.5;
$line-height-loose: 1.8;

$font-weight-normal: 400;
$font-weight-medium: 500;
$font-weight-semibold: 600;
$font-weight-bold: 700;
~~~
## <a name="_toc196130544"></a><a name="_toc196130620"></a><a name="_toc196173550"></a>**А.2.9. Компонент кнопки**
~~~ tsx
// shared/ui/button/Button.tsx
export type ButtonVariant = 'primary' | 'secondary' | 'outline' | 'text';
export type ButtonSize = 'sm' | 'md' | 'lg';

export interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: ButtonVariant;
  size?: ButtonSize;
  fullWidth?: boolean;
  leftIcon?: ReactNode;
  rightIcon?: ReactNode;
}

export const Button: FC<ButtonProps> = ({
  children,
  variant = 'primary',
  size = 'md',
  fullWidth = false,
  leftIcon,
  rightIcon,
  className,
  disabled,
  ...props
}) => {
  return (
    <button
      className={cn(
        styles.button,
        styles[`variant-${variant}`],
        styles[`size-${size}`],
        { [styles.fullWidth]: fullWidth },
        { [styles.disabled]: disabled },
        className
      )}
      disabled={disabled}
      {...props}
    >
      {leftIcon && <span className={styles.leftIcon}>{leftIcon}</span>}
      <span className={styles.content}>{children}</span>
      {rightIcon && <span className={styles.rightIcon}>{rightIcon}</span>}
    </button>
  );
};
~~~
## <a name="_toc196130545"></a><a name="_toc196130621"></a><a name="_toc196173551"></a>**А.2.10. Компонент карточки**
~~~ tsx
// shared/ui/card/Card.tsx
export interface CardProps {
  title?: ReactNode;
  subtitle?: ReactNode;
  image?: string;
  footer?: ReactNode;
  className?: string;
  children: ReactNode;
}

export const Card: FC<CardProps> = ({
  title,
  subtitle,
  image,
  footer,
  className,
  children
}) => {
  return (
    <div className={cn(styles.card, className)}>
      {image && (
        <div className={styles.imageContainer}>
          <img src={image} alt={typeof title === 'string' ? title : 'Card image'} className={styles.image} />
        </div>
      )}
    
      {(title || subtitle) && (
        <div className={styles.header}>
          {title && <h3 className={styles.title}>{title}</h3>}
          {subtitle && <div className={styles.subtitle}>{subtitle}</div>}
        </div>
      )}
    
      <div className={styles.content}>{children}</div>
    
      {footer && <div className={styles.footer}>{footer}</div>}
    </div>
  );
};
~~~
## <a name="_toc196130546"></a><a name="_toc196130622"></a><a name="_toc196173552"></a>**А.2.11. Стили сетки для адаптивной верстки**
~~~ scss
// shared/styles/grid.scss
.container {
  width: 100%;
  margin: 0 auto;
  padding: 0 $spacing-md;
  
  @media (min-width: $breakpoint-sm) {
    max-width: 540px;
  }
  
  @media (min-width: $breakpoint-md) {
    max-width: 720px;
  }
  
  @media (min-width: $breakpoint-lg) {
    max-width: 960px;
  }
  
  @media (min-width: $breakpoint-xl) {
    max-width: 1140px;
  }
  
  @media (min-width: $breakpoint-xxl) {
    max-width: 1320px;
  }
}

.row {
  display: flex;
  flex-wrap: wrap;
  margin: 0 -#{$spacing-sm};
}

.col {
  flex: 0 0 auto;
  width: 100%;
  padding: 0 $spacing-sm;
}

// Генерация классов для колонок
@each $breakpoint in (xs, sm, md, lg, xl, xxl) {
  @for $i from 1 through 12 {
    @if $breakpoint == 'xs' {
      .col-#{$i} {
        flex: 0 0 auto;
        width: percentage($i / 12);
      }
    } @else {
      @media (min-width: map-get($breakpoints, $breakpoint)) {
        .col-#{$breakpoint}-#{$i} {
          flex: 0 0 auto;
          width: percentage($i / 12);
        }
      }
    }
  }
}
~~~
## <a name="_toc196130547"></a><a name="_toc196130623"></a><a name="_toc196173553"></a>**А.2.12. Компонент адаптивного изображения**
~~~ tsx
// shared/ui/responsive-image/ResponsiveImage.tsx
export const ResponsiveImage: FC<ResponsiveImageProps> = ({
  src,
  alt,
  sizes,
  loading = 'lazy',
  className,
  ...props
}) => {
  const webpSrc = src.replace(/.(jpg|jpeg|png)$/, '.webp');
  const baseUrl = src.replace(/.(jpg|jpeg|png)$/, '');
  const extension = src.match(/.(jpg|jpeg|png)$/)?.[0] || '.jpg';
  
  return (
    <picture>
      <source
        type="image/webp"
        srcSet={`
          ${baseUrl}-small.webp 400w,
          ${baseUrl}-medium.webp 800w,
          ${baseUrl}-large.webp 1200w
        `}
        sizes={sizes || '(max-width: 767px) 100vw, 50vw'}
      />
      <source
        type={`image/${extension.substring(1)}`}
        srcSet={`
          ${baseUrl}-small${extension} 400w,
          ${baseUrl}-medium${extension} 800w,
          ${baseUrl}-large${extension} 1200w
        `}
        sizes={sizes || '(max-width: 767px) 100vw, 50vw'}
      />
      <img
        src={src}
        alt={alt}
        loading={loading}
        className={className}
        {...props}
      />
    </picture>
  );
};
~~~
## <a name="_toc196130548"></a><a name="_toc196130624"></a><a name="_toc196173554"></a>**А.2.13. Компонент виртуализированного списка товаров**
~~~ tsx
// features/catalog/ui/VirtualizedProductList.tsx
export const VirtualizedProductList: FC<VirtualizedProductListProps> = ({
  products,
  itemHeight = 300,
  windowWidth
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const [visibleRange, setVisibleRange] = useState({ start: 0, end: 20 });
  
  const calculateColumnCount = useCallback(() => {
    if (windowWidth < 576) return 1;
    if (windowWidth < 992) return 2;
    if (windowWidth < 1200) return 3;
    return 4;
  }, [windowWidth]);
  
  const columnCount = calculateColumnCount();
  const rowCount = Math.ceil(products.length / columnCount);
  
  // Расчет видимых элементов при прокрутке
  const handleScroll = useCallback(() => {
    if (!containerRef.current) return;
  
    const { scrollTop, clientHeight } = containerRef.current;
    const visibleHeight = clientHeight;
  
    const startRow = Math.floor(scrollTop / itemHeight);
    const endRow = Math.ceil((scrollTop + visibleHeight) / itemHeight);

    const bufferRows = 2; // Дополнительные строки для плавного скролла
  
    setVisibleRange({
      start: Math.max(0, startRow - bufferRows) * columnCount,
      end: Math.min(rowCount, endRow + bufferRows) * columnCount
    });
  }, [itemHeight, rowCount, columnCount]);
  
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;
  
    container.addEventListener('scroll', handleScroll);
    handleScroll();
  
    return () => {
      container.removeEventListener('scroll', handleScroll);
    };
  }, [handleScroll]);
  
  const visibleProducts = useMemo(() => {
    return products.slice(visibleRange.start, Math.min(visibleRange.end, products.length));
  }, [products, visibleRange]);
  
  return (
    <div 
      ref={containerRef}
      className={styles.container}
      style={{ height: `${rowCount * itemHeight}px`, overflowY: 'auto' }}
    >
      <div className={styles.grid} style={{ gridTemplateColumns: `repeat(${columnCount}, 1fr)` }}>
        {visibleProducts.map((product) => (
          <div 
            key={product.id}
            className={styles.item}
            style={{ 
              height: `${itemHeight}px`, 
              transform: `translateY(${Math.floor(visibleRange.start / columnCount) * itemHeight}px)` 
            }}
          >
            <ProductCard product={product} />
          </div>
        ))}
      </div>
    </div>
  );
};
~~~
